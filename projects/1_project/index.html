<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Message Passing on Clustered Graphs | Peter S. Mann</title> <meta name="author" content="Peter S. Mann"/> <meta name="description" content="Message passing on clustered networks with edge-disjoint clique covers using `gcmpy`"/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚛️</text></svg>"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://peterstandrews.github.io/projects/1_project/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Peter </span>S. Mann</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Research</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Message Passing on Clustered Graphs</h1> <p class="post-description">Message passing on clustered networks with edge-disjoint clique covers using `gcmpy`</p> </header> <article> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> <td class="code"><pre><span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">gcmpy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="n">nx</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> 
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>[Peter Mann, 2022, University of St Andrews]</p> <h1 id="message-passing-on-clustered-networks">Message passing on clustered networks</h1> <p>In this notebook we will study bond percolation over a coauthorship network, an empirical network of condensed matter physics coauthors [1]. We will do this by solving message passing equations. This network is known to contain short loops, and so, can be challenging to solve analytically due to correlations among the message passing equations. To write our message passing expressions, we will use recent theoretical results [2] in conjunction with an edge-disjoint clique cover. We will use some of the features of <code class="language-plaintext highlighter-rouge">gcmpy</code>, a Python library for working with the configuration model and other network science related tools.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Read in the network from a GML file
</span><span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="n">read_gml</span><span class="p">(</span><span class="s">"cond-mat/cond-mat.gml"</span><span class="p">)</span>

<span class="c1"># pull the largest connected component as a networkx object
</span><span class="n">Gcc</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">nx</span><span class="p">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">H</span><span class="p">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">Gcc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># relabel the vertices with integers
</span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="n">convert_node_labels_to_integers</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</code></pre></div></div> <h2 id="monte-carlo-simulation">Monte Carlo simulation</h2> <p>To start out, lets perform some bond percolation simulations over this network using <code class="language-plaintext highlighter-rouge">gcmpy</code>’s <code class="language-plaintext highlighter-rouge">bond_percolate()</code> routine and visualise the results.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># set the number of repeats and perform the experiments
</span><span class="n">repeats</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">Ss</span> <span class="o">=</span> <span class="p">[[</span><span class="n">gcmpy</span><span class="p">.</span><span class="n">bond_percolate</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="k">for</span> <span class="n">phi</span> <span class="ow">in</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">)]</span> 
                                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">repeats</span><span class="p">))]</span>

<span class="c1"># take the average of the repeats 
</span><span class="n">largest_component_size</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">Ss</span><span class="p">)]</span>
  
<span class="c1"># plot the results
</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">7</span><span class="p">).</span><span class="n">gca</span><span class="p">()</span>
<span class="n">ax</span><span class="p">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">largest_component_size</span><span class="p">)),</span>
           <span class="n">largest_component_size</span><span class="p">,</span><span class="n">marker</span><span class="o">=</span><span class="s">'x'</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s">'r'</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">'Simulation'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s">'Occupation probability $\phi$'</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'Size of largest cluster'</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s">'both'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s">'major'</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
</code></pre></div></div> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/my_images/output_4_2-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/my_images/output_4_2-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/my_images/output_4_2-1400.webp"></source> <img src="/assets/img/my_images/output_4_2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="simulation" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> This simulation results of bond percolation on the coauthorship network. </div> <h1 id="message-passing-model">Message passing model</h1> <p>Now, we would like to create an analytical model using message passing. The first step is to cover the network in cliques, such that each edge belongs to a single clique. There are multiple ways to do this and <code class="language-plaintext highlighter-rouge">gcmpy</code> provides a few different methods (see <code class="language-plaintext highlighter-rouge">EECC()</code> and <code class="language-plaintext highlighter-rouge">MPCC()</code>) [3,4]. Today, we will use the MPCC which stands for <em>motif preserving clique cover</em> [3]. This method finds all of the cliques in a network, placing them into a list; orders them by size before shuffling the list of cliques that have equal size. The list is then iterated such that the largest cliques are first, and for each clique $c$ attempts to include it into the cover $\mathcal C$. A clique can be included in $\mathcal C$ iff all of its edges are available - this is the edge disjoint property. If the clique is included, its edges are marked as unavailable and the next clique is tested. This way, overlapping cliques (that share an edge) cannot both be placed in the cover.</p> <p>The size of the largest connected component $S$ following bond percolation in the message passing model is given by [2]</p> \[S(\phi) = 1 - \frac{1}{N}\sum_i\prod _{\tau\in\tau_i} H_{i\leftarrow \tau}(1)\] <p>The expression to calculate the clique equation is found to be [2]</p> \[H_{i\leftarrow \tau}(z) = \sum_{\kappa=0}^{|\tau|-1}\sum_{m=0}^{\frac 12 \kappa(\kappa-1)}\mathcal Q_{\kappa+1,\frac 12(\kappa+1)\kappa-m}\phi^{\frac 12(\kappa+1)\kappa-m}(1-\phi)^{\omega(r)+m}\sum_{a_{\kappa}\in A_{\kappa}}\prod_{\tau_j\in a_\kappa}\left(z\prod_{\nu\in \nu_{\tau_j}\backslash\tau} H_{\tau_j\leftarrow\nu}(z)\right),\] <p>where $\mathcal Q_{n,k}$ is the number of connected graphs with $n$ vertices and $k$ edges. This can be evaluated numerically by a fast recursive algorithm due to Harary and Palmer [5].</p> \[\mathcal Q_{n, k} = \begin{cases} 0 \qquad &amp;k&lt; n-1,\quad \text{or}\quad k&gt; n(n-1)/2 \\ n^{n-2} \qquad &amp;k = n-1, \quad\\ Q(n,k)\qquad &amp;\text{otherwise}. \end{cases}\] <p>where</p> \[Q(n,k)=\binom{\frac 12n(n-1)}{k}- \sum\limits_{m=0}^{n-2} {n-1\choose m} \sum\limits_{p=0}^k{\frac 12(n-1-m)(n-2-m) \choose p} \mathcal Q_{m+1, k-p}.\] <p>We now have to code this expression. Note, <code class="language-plaintext highlighter-rouge">gcmpy</code> contains a handy implementation of this recursion.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">clique_equation</span><span class="p">(</span><span class="n">tau</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Hs</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="s">'''
    :param tau: size of the clique including focal vertex
    :param phi: bond occupation probability 
    :param Hs: H values for all vertices in the clique apart from focal
    '''</span>
    
    <span class="k">def</span> <span class="nf">omega</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="s">'''
        The number of interface edges for a component of
        kappa vertices in a tau clique. 
        :param tau: clique size
        :param kappa: number of neighbours that the focal vertex connects to
        '''</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">-</span> <span class="n">kappa</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">summation</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">summation</span> <span class="o">+=</span> <span class="p">(</span><span class="n">tau</span><span class="o">-</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">summation</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">summation</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1"># kappa is the number of neighbours that the focal vertex connects to
</span>    <span class="k">for</span> <span class="n">kappa</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tau</span><span class="p">):</span>
        
        <span class="n">factor</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">itertools</span><span class="p">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="n">kappa</span><span class="p">):</span>

            <span class="n">prod</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">H</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">:</span>
                <span class="n">prod</span> <span class="o">*=</span> <span class="n">H</span>

            <span class="n">factor</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>
                
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span><span class="p">(</span><span class="n">kappa</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            
            <span class="n">prefactor</span> <span class="o">=</span> <span class="p">(</span><span class="n">gcmpy</span><span class="p">.</span><span class="n">Q</span><span class="p">(</span><span class="n">kappa</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span><span class="p">(</span><span class="n">kappa</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="n">m</span><span class="p">)</span>
                         <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span><span class="p">(</span><span class="n">kappa</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="n">m</span><span class="p">)</span> 
                         <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">phi</span><span class="p">,</span><span class="n">omega</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span><span class="n">kappa</span><span class="p">)</span><span class="o">+</span><span class="n">m</span><span class="p">))</span>
                
            <span class="n">summation</span> <span class="o">+=</span> <span class="n">prefactor</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">summation</span>  
</code></pre></div></div> <p>The message passing submodule in <code class="language-plaintext highlighter-rouge">gcmpy</code> requires the methods of an abstract class to be defined. This has been left so that motifs other than cliques can be included into the cover without the need for a full re-write of the message passing classes. We then monkey patch our mixin into the <code class="language-plaintext highlighter-rouge">gcmpy</code> class so that at runtime, the methods are defined.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MessagePassingMixin</span><span class="p">():</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cover_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">nx</span><span class="p">.</span><span class="n">Graph</span><span class="p">):</span>
        <span class="s">'''
        Mixin class to pull the motif cover labelling from a network model.
        The cover labelling depends on the motifs in the cover, whereas the
        graph label is constant. In this case, we allow only cliques into the
        model.

        :param cover_type: str of motifs in cover
        :param G: networkx graph with edge labels.
        '''</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_CoverType</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">cover_type</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_G</span><span class="p">:</span> <span class="n">nx</span><span class="p">.</span><span class="n">Graph</span> <span class="o">=</span> <span class="n">G</span>

    <span class="k">def</span> <span class="nf">get_edge_cover_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s">'''
        Interrogates the graph `G' for edge &lt;i,j&gt;'s cover label. Each label
        will depend on the cover that is being used.

        :param i: vertex id
        :param j: vertex id

        :returns string: the cover label
        '''</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_G</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">][</span><span class="s">'clique'</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_motif_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s">'''
        Parses the cover label to get the topology of the edge.

        :param label: the cover label
        :returns string: topology
        '''</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">get_motif_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s">'''
        Parses the cover label to return the unique ID of
        the motif.

        :param str: cover label
        :returns str: unique motif ID
        '''</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">get_vertices_in_motif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="s">'''
        Parses the cover label to return the vertices in
        the motif as a list of integers.

        :param str: cover label
        :returns list: vertex IDs in motif.
        '''</span>
        <span class="k">return</span> <span class="n">ast</span><span class="p">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">label</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MessagePassing</span><span class="p">(</span><span class="n">gcmpy</span><span class="p">.</span><span class="n">MessagePassing</span><span class="p">):</span>
    
    <span class="s">'''
    
    Subclass the builtin functionality of gcmpy to 
    evaluate the newly defined equation, rather than a 
    user-defined dict of callbacks. 
    
    '''</span>
    
    <span class="k">def</span> <span class="nf">resolve_equation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">prods</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="s">'''
        Calculates the probability that connection to the GCC
        fails through this motif. 

        :param topology: str, the toplogy of the motif
        :param prods: a list of floats of `H_{j leftarrow nu}(z)'

        :return float: the probability that connection to the GCC
        fails through this motif.
        '''</span>
        <span class="k">assert</span> <span class="n">topology</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">prods</span><span class="p">)</span> <span class="o">+</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">clique_equation</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">_phi</span><span class="p">,</span> <span class="n">prods</span><span class="p">)</span>
    
</code></pre></div></div> <p>Great, we are now in a position to perform some experiments on the network. To start, we will cover the edges with the simplest form of clique cover: a 2-clique cover. In this case, each edge belongs only to a 2-clique and higher-order relations are ignored.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Extract the MPCC 2-clique cover using gcmpy
</span><span class="n">G</span> <span class="o">=</span> <span class="n">gcmpy</span><span class="p">.</span><span class="n">MPCC</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># create an instance of the MessagePassing class. Don't worry about the arguments for now, they are for
# the callback functionality to evaluate the equations (we are using the clique function from 
# above instead ...)
</span><span class="n">MP</span> <span class="o">=</span> <span class="n">MessagePassing</span><span class="p">(</span><span class="s">'NULL'</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="p">{})</span>

<span class="c1"># insert our newly defined Mixin class for the runtime
</span><span class="n">MP</span><span class="p">.</span><span class="n">_MPM</span> <span class="o">=</span> <span class="n">MessagePassingMixin</span><span class="p">(</span><span class="s">'NULL'</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>

<span class="c1"># perform the experiment!
</span><span class="n">GCC_2_cliques</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">MP</span><span class="p">.</span><span class="n">theoretical</span><span class="p">)(</span><span class="n">phi</span><span class="p">)</span> <span class="k">for</span> <span class="n">phi</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">)))</span>
</code></pre></div></div> <p>Following this, we will extract all cliques from the network and re-run the message passing equations. Finally, once our data is collected, we will visualise the theoretical results.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Extract the MPCC clique cover (all size cliques allowed) using gcmpy
</span><span class="n">G</span> <span class="o">=</span> <span class="n">gcmpy</span><span class="p">.</span><span class="n">MPCC</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="c1"># create an instance of the MessagePassing class. 
</span><span class="n">MP</span> <span class="o">=</span> <span class="n">MessagePassing</span><span class="p">(</span><span class="s">'NULL'</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="p">{})</span>
<span class="n">MP</span><span class="p">.</span><span class="n">_MPM</span> <span class="o">=</span> <span class="n">MessagePassingMixin</span><span class="p">(</span><span class="s">'NULL'</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>

<span class="c1"># perform the experiment! (go make a cup of tea for this one ... )
</span><span class="n">GCC_all_cliques</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">MP</span><span class="p">.</span><span class="n">theoretical</span><span class="p">)(</span><span class="n">phi</span><span class="p">)</span> <span class="k">for</span> <span class="n">phi</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">)))</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># plot the results
</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">7</span><span class="p">).</span><span class="n">gca</span><span class="p">()</span>
<span class="n">ax</span><span class="p">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">largest_component_size</span><span class="p">)),</span>
           <span class="n">largest_component_size</span><span class="p">,</span><span class="n">marker</span><span class="o">=</span><span class="s">'x'</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s">'r'</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">'Simulation'</span><span class="p">)</span>


<span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">GCC_2_cliques</span><span class="p">)),</span> <span class="n">GCC_2_cliques</span><span class="p">,</span><span class="s">'--'</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s">'lime'</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">'2-clique cover'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">GCC_all_cliques</span><span class="p">)),</span> <span class="n">GCC_all_cliques</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s">'k'</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">'MPCC cover'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s">'Occupation probability $\phi$'</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'Size of largest cluster'</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s">'both'</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s">'major'</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
</code></pre></div></div> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/my_images/output_14_1-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/my_images/output_14_1-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/my_images/output_14_1-1400.webp"></source> <img src="/assets/img/my_images/output_14_1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="SimulationandTheory" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> The 2-clique cover and the MPCC cover results of the message passing model for the coauthorship network. </div> <p>The 2-clique cover does not capture the experimental results very well. Allowing larger cliques into the cover yields a better model of the empirical network, but it still isn’t 100% capturing the connectivity of the empirical network. We will investigate the role that clique covers play in future posts!</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># iterate the edges and record the clique size
</span><span class="n">cliques</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">edges</span><span class="p">():</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s">'clique'</span><span class="p">]</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">cliques</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">cliques</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    
<span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">cliques</span><span class="p">:</span>
    <span class="n">cliques</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">/=</span> <span class="n">size</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">7</span><span class="p">).</span><span class="n">gca</span><span class="p">()</span>

<span class="n">ax</span><span class="p">.</span><span class="n">bar</span><span class="p">(</span><span class="n">cliques</span><span class="p">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">cliques</span><span class="p">.</span><span class="n">values</span><span class="p">())</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">cliques</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

<span class="c1"># visualisation stuff ...
</span><span class="n">ax</span><span class="p">.</span><span class="n">spines</span><span class="p">[</span><span class="s">'top'</span><span class="p">].</span><span class="n">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">spines</span><span class="p">[</span><span class="s">'right'</span><span class="p">].</span><span class="n">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">spines</span><span class="p">[</span><span class="s">'left'</span><span class="p">].</span><span class="n">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">spines</span><span class="p">[</span><span class="s">'bottom'</span><span class="p">].</span><span class="n">set_color</span><span class="p">(</span><span class="s">'#DDDDDD'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_axisbelow</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">yaxis</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'#EEEEEE'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">xaxis</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'clique size'</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'count'</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
</code></pre></div></div> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/my_images/output_17_1-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/my_images/output_17_1-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/my_images/output_17_1-1400.webp"></source> <img src="/assets/img/my_images/output_17_1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="SimulationandTheory" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> A distribution of the cliques that are included in the MPCC cover, note the presence of an 18 clique! </div> <h1 id="references">References</h1> <p>[1] M. E. J. Newman, “The structure of scientific collaboration networks,” Proceedings of the National Academy of Sciences, vol. 98, no. 2, pp. 404–409, 200</p> <p>[2] P. Mann &amp; S. Dobson. Belief propagation on networks with cliques and chordless cycles (<em>in preparation, 2022</em>)</p> <p>[3] P. Mann, V. A. Smith, J. B. O. Mitchell, and S. Dobson, “Degree correlations in graphs with clique clustering,” Phys. Rev. E, vol. 105, p. 044314, Apr 2022</p> <p>[4] G. Burgio, A. Arenas, S. Gomez, and J. T. Matamalas, “Network clique cover approximation to analyze complex contagions through group interactions,” Communications Physics, vol. 4, no. 1, 2021</p> <p>[5] F. Harary and E. M. Palmer, Graphical enumeration. Academic Press, 1973.</p> <p>[6] https://github.com/giubuig/DisjointCliqueCover.jl</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2022 Peter S. Mann. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="noopener noreferrer">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> </body> </html>